这种方式无需自建后端数据库，直接通过前端（或脚本）调用公开接口获取数据，适合轻量级基金分析工具的快速实现。

//我想把那理由，移动到原本显示操作建议（右边的那个地方），然后理由。以及，我记录备注的按钮在checkbox下面，点击复选框和记录按钮现在分开来。不需要跳出操作类型啥的，让我直接打字，当作我操作的思考即可，然后上面要有个清除操作记录的按钮，方便下次记录。当日如果没删除，点击就还可以再看到我的备注记录，可以更改。


1.脚本根据提供基金名，进行模糊搜索，并匹配得到基金代码。
//基金代码_未匹配候选项.csv（未匹配项 + difflib 给出的候选名称与相似度，方便人工选定）
有相似度阈值，先返回，人工确认
2.同向涨跌幅，连续n天，超过x%，则触发交易信号

自动规则计算信号强度（简单实用）

根据涨跌幅的绝对值或连续涨跌的程度，自动生成一个 0~1 的强度数值。
比如：

strength = min(1.0, abs(consecutive_change_pct) / 10)


如果连续涨跌 10% 以上就算强度满格（1.0），
涨跌 3% 就是 0.3，涨跌 6% 就是 0.6。

你的意思是：

连续方向判定不是单纯看最后一天，而是看最近 5 天里“多数天”的方向。

如果出现持平（涨跌为 0），就不算入统计天数，但不改变方向判断。

例如，最近 4 天涨跌：[-1.0, -0.5, 0.0, -0.8]

跌 3 天，平 1 天 → 方向判定为 跌

连续天数统计时，零天不算入连续计数，但不改变方向。

可以这样改逻辑：

统计最近 5 天的涨跌（不包括零天）。

判断方向：

recent_history = [delta for delta in history[-5:] if delta != 0]
if not recent_history:
    direction = 0
else:
    pos_count = sum(1 for x in recent_history if x > 0)
    neg_count = sum(1 for x in recent_history if x < 0)
    direction = 1 if pos_count >= neg_count else -1


计算连续天数：

从最近一天开始往前，只要方向和 direction 一致，就累加天数。

零天直接跳过。

示例

//连续同向天数
根据多数方向判定，从最近一天开始统计，零天不计入


假设最近 5 天涨跌：

history = [-1.0, -0.5, 0.0, -0.8, 0.3]  # 最近一天在最后


最近 5 天非零：[-1.0, -0.5, -0.8, 0.3]

统计方向：跌 3 天，涨 1 天 → 方向 = 跌

连续天数从最后一天往前：

0.3 → 与方向不符，连续中断

前面 0.0 → 跳过

-0.8 → 符合 → count = 1

-0.5 → 符合 → count = 2

-1.0 → 符合 → count = 3

最终：连续跌 3 天，方向 = 跌。


3.数据获取
api,获取当日

原来的方式
history = fetch_history(code, days=20) + [daily_change_pct]


fetch_history 用天天基金 API 获取最近 N 天净值涨跌（接口可能不稳定，或者返回空）

然后 强行在末尾加上 daily_change_pct（来自 fundgz 或 eastmoney）

问题：

如果今天 fundgz 数据没更新，今天涨跌就算 0

连续统计结果直接受今天数据影响 → 所以你看到连续天数永远是 1 或 0

历史抓取的天数多也没用，因为连续统计总是被末尾的今天数据覆盖

2️⃣ 现在的方式
history = fetch_history_nav(code, days=5)
daily_change_pct = fetch_today_change(code)  # fundgz 或 eastmoney


历史净值抓最近 5 个交易日的涨跌百分比，不加今天的数据

今日涨跌单独用 fundgz API 或 eastmoney API 获取

连续统计可以选择是否包含今天：

如果今天有数据 → 就把今日涨跌加到历史列表末尾计算连续

如果今天还没数据 → 只用历史连续统计到昨天

优点：

历史连续计算不被今天数据干扰

今天数据独立，真实可靠

连续天数统计更稳健

4.没抓到到数据，要先测试


5.它显示的排序逻辑有问题。先看超不超，超了再按单日涨跌从大到小，再按连续的涨跌大小一次排序。只展示超了的基金